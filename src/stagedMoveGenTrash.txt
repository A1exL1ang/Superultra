#include "types.h"
#include "helpers.h"
#include "movepick.h"
#include "search.h"
#include "movescore.h"

const static int stageTT = 0;
const static int stageGenerate = 1;
const static int stageScoreNoisy = 2;
const static int stageGoodNoisy = 3;
const static int stagePrimaryKiller = 4;
const static int stageSecondaryKiller = 5;
const static int stageCounter = 6;
const static int stageScoreQuiets = 7;
const static int stageRestOfMoves = 8;
const static int stageDone = 9;

// TODO: rename to unscored
// Set everything to unscore in a neater way

const static Movescore mvvlva[7][7] = {
    {},                                      // Victim: None
    {0, 2050, 2040, 2030, 2020, 2010, 2000}, // Victim: Pawn
    {0, 3050, 3040, 3030, 3020, 3010, 3000}, // Victim: Knight
    {0, 4050, 4040, 4030, 4020, 4010, 4000}, // Victim: Bishop
    {0, 5050, 5040, 5030, 5020, 5010, 5000}, // Victim: Rook
    {0, 6050, 6040, 6030, 6020, 6010, 6000}, // Victim: Queen
    {}                                       // Victim: King
};

const static Movescore maximumHist = 16384;

const static Movescore ttMoveScore            = 2000000000;
const static Movescore promoScore             = 1900000000;
const static Movescore goodCaptScore          = 1800000000;
const static Movescore primaryKillerScore     = 1700000000;
const static Movescore secondaryKillerScore   = 1600000000;
const static Movescore counterScore           = 1500000000;
const static Movescore nonspecialMoveScore    = 1400000000;
const static Movescore badCaptScore           = 1300000000;
const static Movescore unscoredScore          = 0; // Make this infinitely smaller than the rest

const static Movescore promoScoreBonus[7] = { 0, 0, 1, 2, 3, 4, 0 };

static inline void updateHistoryValue(Movescore &cur, Movescore bonus){
    // We use history gravity which means we scale based on its current magnitude
    // new bonus = bonus * (1 - |value| / max value)
    cur += bonus - static_cast<uint64>(abs(bonus)) * static_cast<uint64>(cur) / maximumHist;
}

static inline Movescore calcBonus(Depth depth){
    return std::min(8 * depth * depth + 32 * std::max(depth - 1, 0), 1200);
}

Movescore getQuietHistory(Move move, Depth ply, position &board, searchData &sd, searchStack *ss){
    Movescore score = 0;

    score += sd.history[board.getTurn()][moveFrom(move)][moveTo(move)];
    
    if (ply >= 1 and (ss - 1)->move != nullOrNoMove){
        score += 2 * (*(ss - 1)->contHist)[board.movePieceEnc(move)][moveTo(move)];
    }
    if (ply >= 2 and (ss - 2)->move != nullOrNoMove){
        score += 2 * (*(ss - 2)->contHist)[board.movePieceEnc(move)][moveTo(move)];
    }
    return score;
}

void updateAllHistory(Move bestMove, moveList &quiets, Depth depth, Depth ply, position &board, searchData &sd, searchStack *ss){
    // Set killer
    if (bestMove != sd.killers[ply][0]){
        sd.killers[ply][1] = sd.killers[ply][0];
        sd.killers[ply][0] = bestMove;
    }
    // Set counter
    if (ply >= 1 and (ss - 1)->move != nullOrNoMove){
        *(ss - 1)->counter = bestMove;
    }
    // Update history values by penalizing failing moves and incrementing best move
    for (int i = 0; i < quiets.sz; i++){
        Move move = quiets.moves[i].move;
        Movescore bonus = calcBonus(depth) * (move == bestMove ? 1 : -1);
            
        updateHistoryValue(sd.history[board.getTurn()][moveFrom(move)][moveTo(move)], bonus);

        if (ply >= 1 and (ss - 1)->move != nullOrNoMove){
            updateHistoryValue((*(ss - 1)->contHist)[board.movePieceEnc(move)][moveTo(move)], bonus);
        }   
        if (ply >= 2 and (ss - 2)->move != nullOrNoMove){
            updateHistoryValue((*(ss - 2)->contHist)[board.movePieceEnc(move)][moveTo(move)], bonus);
        }
    }   
}

void scoreMoves(moveList &moves, Move ttMove, Depth ply, position &board, searchData &sd, searchStack *ss){
    for (int i = 0; i < moves.sz; i++){
        // Step 0) Variables
        Move move = moves.moves[i].move;
        Movescore &score = moves.moves[i].score;

        // Step 1) ttMove
        if (move == ttMove){
            score = ttMoveScore;
        }

        // Step 2) Promotion
        else if (movePromo(move)){
            score = promoScore + promoScoreBonus[movePromo(move)];
        }

        // Step 3) Capture
        else if (board.moveCaptType(move)){
            score = (board.seeGreater(move, -50) ? goodCaptScore : badCaptScore) 
                  + mvvlva[board.moveCaptType(move)][board.movePieceType(move)];
        }

        // Step 4) Killer 1
        else if (move == sd.killers[ply][0]){
            score = primaryKillerScore;
        }

        // Step 5) Killer 2
        else if (move == sd.killers[ply][1]){
            score = secondaryKillerScore;
        }

        // Step 6) Countermove
        else if (ply >= 1 and (ss - 1)->move != nullOrNoMove and move == *((ss - 1)->counter)){
            score = counterScore;
        }

        // Step 7) Rest of the moves
        else{
            score = nonspecialMoveScore + getQuietHistory(move, ply, board, sd, ss);
        }
    }
}

movePicker::movePicker(bool onlyNoisy_, position &board_, Move ttMove_, Depth ply_, searchData &sd_, searchStack *ss_): 
    onlyNoisy(onlyNoisy_),
    board(board_),
    ttMove(ttMove_),
    ply(ply_),
    sd(sd_),
    ss(ss_)
{
    // One reason we declare the constructor here so that the scope of stageTT is this file
    stage = stageTT;
    pos = 0;

    killer1 = sd.killers[ply][0];
    killer2 = sd.killers[ply][1];
    counter = (ply >= 1 and (ss - 1)->move != nullOrNoMove) ? *((ss - 1)->counter) : nullOrNoMove;
}

void movePicker::bringBest(){
    int best = pos;
    for (int i = pos + 1; i < ml.sz; i++){
        if (ml.moves[i].score > ml.moves[best].score){
            best = i;
        }
    }
    std::swap(ml.moves[pos], ml.moves[best]);
}

bool movePicker::bringMove(Move targetMove){
    for (int i = pos; i < ml.sz; i++){
        if (ml.moves[i].move == targetMove){
            std::swap(ml.moves[pos], ml.moves[i]);
            return true;
        }
    }
    return false;
}

void movePicker::initScores(){
    // All scores are initially: unscoredScore
    for (int i = pos; i < ml.sz; i++){
        ml.moves[i].score = unscoredScore;
    }
}

void movePicker::scoreNoisy(){
    for (int i = pos; i < ml.sz; i++){
        // Variables
        Move move = ml.moves[i].move;
        Movescore &score = ml.moves[i].score;

        // If it is the TT move, we skip
        if (move == ttMove){
            continue;
        }

        // Score promotion
        if (movePromo(move)){
            score = promoScore + promoScoreBonus[movePromo(move)];
        }

        // Score capture
        else if (board.moveCaptType(move)){
            score = (board.seeGreater(move, -50) ? goodCaptScore : badCaptScore) 
                  + mvvlva[board.moveCaptType(move)][board.movePieceType(move)];
        }
    }
}

void movePicker::scoreQuiets(){
    for (int i = pos; i < ml.sz; i++){
        // Variables
        Move move = ml.moves[i].move;
        Movescore &score = ml.moves[i].score;

        // If it is the TT move or killer/counter we skip
        if (move == ttMove or move == killer1 or move == killer2 or move == counter){
            continue;
        }

        // If we have already scored it then skip
        if (score != unscoredScore){
            continue;
        }

        // At this point the move must be quiet
        score = nonspecialMoveScore + getQuietHistory(move, ply, board, sd, ss);
    }
}

Move movePicker::getNext(){
    switch (stage){
        case stageTT:
            // Either way we are gonna go to the next stage (put this in front)
            stage = stageGenerate;

            // Is legal and must be noisy if we are only searching noisy (note that moveCaptType requires move to be legal)
            if (ttMove != nullOrNoMove
                and !(onlyNoisy and movePromo(ttMove) == noPiece and board.moveCaptType(ttMove) == noPiece)
                and board.isLegal(ttMove))
            {
                return ttMove;
            }
            [[fallthrough]];

        case stageGenerate:
            // If the TT move is bad, we generate all moves with the fully legal move gen
            board.genAllMoves(onlyNoisy, ml);
            stage = stageScoreNoisy;
            [[fallthrough]];
        
        case stageScoreNoisy:
            // After we generate, we set all scores to 0 and score all the noisy moves
            initScores();
            scoreNoisy();

            stage = stageGoodNoisy;
            [[fallthrough]];
        
        case stageGoodNoisy:
            // Select the move with the highest score
            bringBest();

            if (pos < ml.sz and ml.moves[pos].score >= goodCaptScore){
                return ml.moves[pos++].move;
            }

            stage = stagePrimaryKiller;

            // If only noisy moves, fall past the quiet move portion
            if (onlyNoisy){
                stage = stageRestOfMoves;
            }
            [[fallthrough]];
        
        case stagePrimaryKiller:
            // Bring the killer move (we must ensure quietness -- it is guarenteed that killer/counter arent promo)
            if (killer1 != ttMove and board.moveCaptType(killer1) == noPiece){
                if (bringMove(killer1)){
                    stage = stageSecondaryKiller;
                    return ml.moves[pos++].move;
                }
            }
            stage = stageSecondaryKiller;
            [[fallthrough]];
        
        case stageSecondaryKiller:
            // Bring the killer move (we must ensure quietness -- it is guarenteed that killer/counter arent promo)
            if (killer2 != ttMove and killer2 != killer1 and board.moveCaptType(killer2) == noPiece){
                if (bringMove(killer2)){
                    stage = stageCounter;
                    return ml.moves[pos++].move;
                }
            }
            stage = stageCounter;
            [[fallthrough]];
        
        case stageCounter:
            // Bring the counter move (we must ensure quietness -- it is guarenteed that killer/counter arent promo)
            if (counter != ttMove and counter != killer1 and counter != killer2 and board.moveCaptType(counter) == noPiece){
                if (bringMove(counter) and ml.moves[pos].score == unscoredScore){
                    stage = stageScoreQuiets;
                    return ml.moves[pos++].move;
                }
            }
            stage = stageScoreQuiets;
            [[fallthrough]];
        
        case stageScoreQuiets:
            // Score rest of moves
            scoreQuiets();
            stage = stageRestOfMoves;
            [[fallthrough]];

        case stageRestOfMoves:
            // Handle rest of moves
            bringBest();

            if (pos < ml.sz and ml.moves[pos].score != unscoredScore){
                return ml.moves[pos++].move;
            }
            stage = stageDone;  
    }
    return nullOrNoMove;
}







bool position::isLegal(Move move){
    // Init
    Square st = moveFrom(move);
    Square en = moveTo(move);
    Piece pieceType = movePieceType(move); 
    Color col = movePieceColor(move);
    Piece promo = movePromo(move);

    // Part 1) Our first step is to deal with all the special cases. This includes no piece / wrong color,
    // friendly piece at the destination, invalid promotion, enpassant, and king moves (including castling). 

    // We aren't moving any piece or wrong color
    if (pieceType == noPiece or col != turn){
        return false;
    }

    // Friendly piece at en
    if ((1ULL << en) & colorBB[turn]){
        return false;
    }

    // Invalid pawn promotion (not at end but promo or at end but no promo)
    if (pieceType == pawn and ((getRank(en) == (turn == white ? 7 : 0)) != (promo != noPiece))){
        return false;
    }

    // Non-pawn tries to promote
    if (pieceType != pawn and promo != noPiece){
        return false;
    }

    // En passant (pawn moves diagonally but doesn't capture anything)
    if (pieceType == pawn
        and ((1ULL << en) & pawnAttack(st, turn))
        and !((1ULL << en) & colorBB[!turn]))
    {
        // If we can't do en passant
        if (pos[stk].epFile == noEP)
            return false;

        Square epEnemyPawn = pos[stk].epFile + (turn == white ? 32 : 24);
        Square epDestination = pos[stk].epFile + (turn == white ? 40 : 16);

        // Move destination not equal to en passant destination
        if (en != epDestination)
            return false;

        Bitboard occupancyAfter = (allBB ^ (1ULL << st) ^ (1ULL << epDestination) ^ (1ULL << epEnemyPawn));
        
        // Good if no discovered attacks and not already in check. This is en passant so need to clear
        // out enemy pawn

        return !(pawnAttack(kingSq(turn), turn) & (pieceBB[pawn][!turn] & (~(1ULL << epEnemyPawn))))
                and !(knightAttack(kingSq(turn)) & pieceBB[knight][!turn])
                and !(bishopAttack(kingSq(turn), occupancyAfter) & pieceBB[bishop][!turn])
                and !(rookAttack(kingSq(turn), occupancyAfter) & pieceBB[rook][!turn])
                and !(queenAttack(kingSq(turn), occupancyAfter) & pieceBB[queen][!turn]);
    }

    // King move
    if (pieceType == king){

        // Note that we xray through our king
        Bitboard attacked = allAttack(!turn, allBB ^ pieceBB[king][turn]);
        Bitboard moves = (kingAttack(st) & (~attacked) & (~colorBB[turn]));

        if (turn == white){
            moves |= (1ULL << g1) * ((pos[stk].castleRights & castleWhiteK) and !(attacked & getLine(e1, g1)) and !(allBB & getLine(f1, g1)))
                   | (1ULL << c1) * ((pos[stk].castleRights & castleWhiteQ) and !(attacked & getLine(e1, c1)) and !(allBB & getLine(b1, d1)));
        }
        else{
            moves |= (1ULL << g8) * ((pos[stk].castleRights & castleBlackK) and !(attacked & getLine(e8, g8)) and !(allBB & getLine(f8, g8)))
                   | (1ULL << c8) * ((pos[stk].castleRights & castleBlackQ) and !(attacked & getLine(e8, c8)) and !(allBB & getLine(b8, d8)));
        }
        return static_cast<bool>((1ULL << en) & moves);
    }

    // Part 2) With the special cases out of the way, now we are left with "normal" moves. We first have
    // to check whether a piece of the given type can move from st to en (for example a rook cannot do a diagonal move).
    // Then we check whether moving the piece from st to en reveals any discovered attacks to the king

    // Pawn psuedolegalality
    if (pieceType == pawn){

        // Rank relative to stm
        Bitboard pawnPushEnd = (pawnsUp((1ULL << st), turn) & (~allBB));
        Bitboard pawnDoublePushEnd = (pawnsUp((pawnPushEnd & allInRank[turn == white ? 2 : 5]), turn) & (~allBB));
        Bitboard pawnAttackEnd = (pawnAttack(st, turn) & colorBB[!turn]);

        // Not psuedolegal
        if (!((1ULL << en) & (pawnPushEnd | pawnDoublePushEnd | pawnAttackEnd))){
            return false;
        }
    }

    // Knight psuedolegality
    if (pieceType == knight and !((1ULL << en) & knightAttack(st))){
        return false;
    }

    // Bishop psuedolegality
    if (pieceType == bishop and !((1ULL << en) & bishopAttack(st, allBB))){
        return false;
    }

    // Rook psuedolegality
    if (pieceType == rook and !((1ULL << en) & rookAttack(st, allBB))){
        return false;
    }

    // Queen psuedolegality
    if (pieceType == queen and !((1ULL << en) & queenAttack(st, allBB))){
        return false;
    }

    // Don't xor (1ULL << en) since that bit may be set if we are capturing a piece at en.
    // Also make sure to clear out the captured piece from pieceBB

    Bitboard occupancyAfter = (allBB ^ (1ULL << st)) | (1ULL << en);

    return !(pawnAttack(kingSq(turn), turn) & (pieceBB[pawn][!turn] & (~(1ULL << en))))
            and !(knightAttack(kingSq(turn)) & (pieceBB[knight][!turn] & (~(1ULL << en))))
            and !(bishopAttack(kingSq(turn), occupancyAfter) & (pieceBB[bishop][!turn] & (~(1ULL << en))))
            and !(rookAttack(kingSq(turn), occupancyAfter) & (pieceBB[rook][!turn] & (~(1ULL << en))))
            and !(queenAttack(kingSq(turn), occupancyAfter) & (pieceBB[queen][!turn] & (~(1ULL << en))));
}